---
toc: True
tags: network book-review
---

# 1. 네트워크 첫걸음

![img](https://user-images.githubusercontent.com/67637935/131210454-1b57f469-a386-4e84-a617-154f2926c4ad.png)

## 네트워크 구조
* 인터넷: 전 세계의 큰 네트워크부터 작은 네트워크까지 연결하는 거대한 네트워크를 의미한다.
* 패킷: 네트워크를 통해 전송되는 데이터의 작은 조각
  * 큰 데이터가 있더라도 작게 나누어서 보내는게 규칙
  * 큰 데이터를 그대로 보내게 되면 그 데이터가 네트워크의 *대역폭*을 많이 점유하게 되어서 다른 패킷의 흐름을 막게된다.
  * 작게 나눠서 보내지는 데이터들은 "순번"이 정해져서 보내진다. 그렇기에 패킷이 제각각 오게 되더라도 "순번"에 맞추어 기존의 형태로 "복원"할 수 있게 된다.

## 정보의 양을 나타내는 단위
* bit 최소의 단위, 8bit:1byte, 
* 0,1의 연속으로 이루어진 것이 잘려지게 되고(패킷 분할) 전송되어진다. (ASCII로 복원)
* 실제 네트워크는 "전기적 신호"로 전송된다.

## LAN & WAN
* 접속할 수 있는 범위에 따라 크게 두가지 종류로 나눌 수 있음
  * LAN(Local Area Network): 특정 건물 안이나 특정 지역을 범위로 하는 네트워크
    * 비교적 빠르고, 오류가 적음, 범위는 한정
  * WAN(Wide Area Network): 지리적으로 넓은 범위에 구축된 네트워크
    * ISP(Internet Service Provider)을 통해 멀리 있는 곳까지 네트워크를 연결할 수 있다.
    * 비교적 느리고, 오류가 많음, 범위는 넓음(LAN과 LAN을 연결)

## 가정에서 하는 랜 구성
* 랜을 구성하기 위해서는 다른 곳에서 네트워크(WAN)을 받아 올 수 있는 ISP가 필요하고, 인터넷 회선이 필요하다.
* Broadband router(인터넷 공유기): 인터넷 서비스 제공자와 네트워크를 연결하기 위한 장비
* 인터넷 공유기 중심으로 내부 인터넷망(사설망)을 구성하고, 다양한 기기를 연결할 수 있다. (사설네트워크 대역:192.168.0.xxx)
* 연결 방식은 "유선 랜", "무선 랜"으로 나눠지게 된다.

## 회사에서 하는 랜 구성
* **DMZ**의 차이가 존재한다.
  * DMZ(DeMilitarized Zone): 외부에 공개하기 위한 네트워크
  * 무엇을 외부에 공개하는가?!: 서버(웹서버, 메일 서버, DNS서버)등을 공개
    * 웹 사이트를 불특정 다수의 이용자에게공개하려면 웹서버를 외부에 공개해야하고, 외부 사용자와 메일을 주고받으려면 메일 서버를 외부에 공개하고, 외부에서 도메인 이름을 사용하여 회사의 서버에 접속하려면 DNS서버를 외부에 공개해야함
  * 인터넷인 외부 네트워크와 내부 네트워크 사이에 위치한 중간지대(서브넷)을 말한다.
  * 네트워크의 보안 영역으로 외부 공격자가 내부 네트워크에 침투하는 것을 막는 역할을 한다.
* 서버를 데이터 센터에 두거나 클라우드에 두는 경우도 있다.
* on-premise: 데이터 센터에 서버를 두고 운영하는 것
* 랙을 설치하기 적합한 형태와 크기를 가진 서버와 라우터와 스위치를 설치할 수 있는데, 라우터는 무선 랜 기능이 있는 라우터를 사용한다.
* 각 서버는 *스위치*와 연결하여 서로 통신할 수 있음

# 2. 네트워크의 기본 규칙

## 네트워크의 규칙

### 프로토콜이란?
* 문제 없이 통신하기 위해서는 규칙(약속)을 지켜야한다.
* 통신을 하기위해서 통신하는 방법부터 전체적으로 진행되는 모든 것을 지키는 과정

## OSI 모델과 TCP/IP 모델

### OSI 모델이란?
* A사와 B사끼리 통신하려고 하는데, 케이블부터 커넥터까지 모두가 다 다르게된다면 연결할 수 없을 것이다. 그럼으로 이것들을 공통으로 사용할 수 있는 *표준규격* 을 정하는 것이 OSI모델이다.
* ISO에서 지정
* 7개의 layer가 존재한다. (응,표,세,전,네,데,물)
  * 7layer: 응용 계층(Application Layer)(이메일&파일전송, 웹 사이트 조회등 어플리케이션에 대한 서비스를 제공한다.)
  * 6layer: 표현 계층(Presentation Layer)(문자 코드 압축, 암호화 등의 데이터를 변환한다.)
  * 5layer: 세션 계층(Session Layer)(세션 체결, 통신 방식을 결정한다.)
  * 4layer: 전송 계층(Transfer Layer)(신뢰할 수 있는 통신을 구현한다.)
  * 3layer: 네트워크 계층(Network Layer)(다른 네트워크와 통신하기 위한 경로 설정 및 논리 주소를 결정한다.)
  * 2layer: 데이터 링크 계층(Data Link Layer)(네트워크 기기 간의 데이터 전송 및 물리 주소를 결정한다.)
  * 1layer: 물리 계층(Physical Layer)(시스템간의 물리적인 연결과 전기 신호를 변환 및 제어한다.)

![p26](https://user-images.githubusercontent.com/67637935/132121730-e114ef32-d6b6-4346-9d47-572e542f1a1a.jpeg)

* 송신측은 데이터를 보내기 위해서 상위 계층에서 하위 계층으로 데이터 전달
* 수신측은 하위 계층에서 상위 계층으로 데이터 전달
* 각 계층은 프로토콜을 각각 같고 있으며, 독립적임

### TCP/IP 모델이란?
* 4개의 layer가 존재한다.
 * 4layer: 응용계층(OSI-7~5)
 * 3layer: 전송계층(OSI-4)
 * 2layer: 인터넷 계층(OSI-3)
 * 1layer: 네트워크접속계층(OSI-2~1)

![OSI_7_계층과_TCPIP](https://user-images.githubusercontent.com/67637935/132122800-8d76544f-161f-438b-8816-29b7da1a78af.jpeg)

## 캡슐화와 역캡슐화

### 캡슐화와 역캡슐화란?
* 데이터를 보내기 위해서는, 데이터의 앞부분에 전송하는 데 필요한 정보를 붙여서 다음계층으로 보내게 된다. 이 정보들을 '헤더'라고 하고, 이 과정을 캡슐화라고 한다.
* 헤더에는 데이터를 전달받을 상대방에 대한 정보도 포함되어있다.
* 데이터를 받는 쪽에서는 그 받은 데이터의 헤더를 하나씩 제거해야하는데 이 과정을 역캡슐화라 한다.

![데이터_캡슐화](https://user-images.githubusercontent.com/67637935/132122818-65c14fe7-da7a-4b94-b117-3b8e80dc0525.jpeg)

* 데이터 링크 계층에서는 헤더와, 트레일러(데이터를 전송할때 마지막으로 추가하는 정보)를 모두 붙이게된다. 
* 최종적으로 트레일러까지 모두 붙이게된 것이 전기신호가 되어 수신측 데이터 링크 계층으로 전달되게 된다.

* 제거하는 과정은 그 역순으로 이뤄진다.

## VPN
* 가상 통신 터널을 만들어 기업본사나 지사와 같은 거점 간을 연결하여 통신하거나 외부에서 인터넷으로 사내 접속을 하는 과정을 말한다.
* 인터넷VPN(거점 간 접속,원격 접속 연결), IP-VPN(폐쇠망 이용[MPSL])

# 3. (OSI 1계층) 물리 계층: 데이터를 전기신호로 변환하기

## 물리 계층의 역할과 랜 카드의 구조

### 전기신호란?
* 0과 1만으로 이루어진 비트열을 전기 신호로 변환하려면 '물리계층'의 기술이 필요하다.
* 디지털신호(불연속적) and 아날로그신호(연속적)

### 랜카드란?
* 0과 1을 불연속적인 디지털신호로 바꿔주는 기기
* 네트워크를 통해 데이터를 송수신할 수 있도록 '랜 카드'가 메인보드에 포함되어 있는 내장형 랜카드나 별도의 랜 카드를 갖고 있다.
* 물리계층에서 랜카드가 있어서 네트워크에서 데이터를 주고받을 수 있다.

## 케이블의 종류와 구조

### 트위스트 페어 케이블이란?
* 데이터의 전송 매체에 대한 것 크게 두가지: "유선", "무선"
  * 유선: 트위스트 페어 케이블, 광케이블
  * 무선: 라디오파, 마이크로파, 적외선
* Tiwisted pair cable(랜케이블): UTP 케이블, STP 케이블
  * UTP: 네 쌍의 전선으로 실드(Sheild)로 보호되어 있지 않은 케이블
  * Shield: 금속 호일이나 금속의 매듭과 같은 것(노이즈 방지)
  * STP: UTP + Sheild로 노이즈 영향을 매우 적게 받지만, 가격때문에 비싸서 잘 안씀

### 다이렉트 케이블과 크로스 케이블이란?
* 1,2,3,6번 구리선만 사용함
* 다이렉트 케이블: 구리 선 여덟 개를 같은 순서로 커넥터에 연결한 케이블
  * 컴퓨터와 스위치를 연결할 때 사용
* 크로스 케이블: 리 선 여덟 개 중 한쪽 커넥터의 1번과 2번에 연결되는 구리선을 다른 쪽 커넥터의 3번과 6번에 연결한 케이블
  * 컴퓨터간의 데이터 충돌을 피하기 위해 크로스로 사용
  * 컴퓨터 간에 직접 랜 케이블로 연결할 때 사용

## 리비터와 허브의 구조

### 리피터란?
* 물리계층에서 동작
* 전기 신호를 정형(일그러진 전기 신호를 복원)하고 증폭하는 기능을 가진 네트워크 중계 장비
* 상대방과 물리적인 거리가 멀때 사용하는 것

### 허브란?
* 물리계층에서 동작
* 포트(실제로 통신하는 통로)를 여러개 가지고 있고, 포트의 수가 많기에 컴퓨터 여려대와도 통신할 수 있음
* 전기 신호를 정형하고 증폭함
* 단점이 허브는 데이터를 송신할 때 모든 연결된 컴퓨터로 신호를 다보낸다.
* 전기 신호를 모든 포트로 보내서 더미 허브라는 이름으로 불리기도 한다.
* 이 대첵으로 나온 것이 스위치이다.


# 4. (OSI 2계층) 데이터 링크 계층: 랜에서 데이터 전송하기

## 데이터 링크 계층의 역할과 이더넷

### 이더넷이란?
* 랜에서 데이터를 주고 받으려면 "데이터 링크 계층"의 기술이 필요하다
* 데이터 링크 계층은 "네트워크 장비 간에 신호를 주고받는 규칙"을 정하는 계층
* 일반적으로 가장 많이 사용되는 규칙이 "이더넷" 규칙이다.
* 허브의 단점: 연결되어 있는 모든 LAN에 데이터를 전송한다. (허브더미)
* 허브의 단점을 방지하기 위해서 데이터에 "목적지 정보를 추가"해서 보내고 이외의 컴퓨터는 데이터를 받더라도 무시하게 되어있음.
* 여러대가 동시에 데이터를 보내게되면 데이터 충동(collision)이 발생하게 된다.
* 이를 방지하기 위해서 데이터를 보내는 시점을 늦추게 된다. --> *CSMA/CD*
  * CS: 데이터를 보내려고 하는 컴퓨터가 케이블에 신호가 흐르고 있는지 유무를 판단한다.
  * MA: 케이블에 데이터가 흐르고 있지 않다면 데이터를 보내도 좋다는 규칙
  * CD: 충돌이 발생하고 있는지를 확인한다.
* 효율이 좋지 않기 때문에 허브withCSMA/CD 보다 Switch를 사용한다.

## MAC 주소의 구조

### MAC 주소란?
* 랜 카드는 비트열을 전기신호로 변환해줌(OSI 1계층), 이러한 랜카드에는 MAC 주소라는 고유 번호(물리주소)가 정해져있다.
* MAC 주소는 48bit로 구성되어있다. (파악하기 쉽게 16진수로 구성되어있음)
  * eg) 00-23-AE-D9-7A-9A
    * 앞쪽 24 bit: 랜카드를 만든 제조사 번호
    * 뒤쪽 24 bit: 제조사가 랜카드에서 붙인 일련번호
* 2계층에서는 "이더넷 헤더"와 -트레일러-를 붙여서 캡슐화를 진행한다.
  * 이더넷 헤더(14byte): 
    * 목적지 MAC 주소(6byte) --> 24 bit
    * 출발지 MAC 주소(6byte) --> 24 bit
    * 유형 2(byte): 이더넷으로 전송되는 상위 계층 프로토콜의 종류를 나타냄(IPv4:0800/ARP:0806/RARP:8035/Ethernet:814C/IPv6:86DD).. " 프로토콜 종류를 식별하는 번호 "
  * 트레일러: FCS(Frame Check Sequnece) 데이터 전송 도중에 오류가 발생하는지 확인하는 용도
* 헤더와 트레일러가 추가된 데이터를 "프레임" 이라고한다. 
* 보내는 측의 컴퓨터 1에서 캡슐화가 일어나고 데이터 링크 계층에서 헤더와 트레일러를 추가하여 프레임을 만들고, 물리계층에서 이 프레임 비트열을 전기신호로 변환하여 네트워크를 통해 전송함.
* 허브 기준 해당되는 전기 신호의 목적지 MAC 주소가 자신과 같지 않으면 데이터를 파기함
* 목적지가 같은 곳에서는 역캡슐화가 일어나게 되고, 데이터를 수신하게됨
* 컴퓨터 1,2가 동시에 컴퓨터 3에게 데이터를 전송할 경우 충돌을 방지하기 위해서 CSMA/CD 방식이 사용됨

## 스위치 구조

### MAC 주소 테이블이란?
* 스위치 내부에는 MAC 주소 테이블이라는 것이 있어, 스위치의 포트 번호와 해당 포트에 연결되어 있는 컴퓨터의 MAC 주소가 등록되는 데이터베이스이다.
* 스위치 전원을 켠 상태에서 아직 MAC 주소가 추가된 프레임이라는 데이터가 전송되면 MAC 주소 테이블을 확인하고 출발지 MAC 주소가 등록되어 있지 않으면 MAC 주소를 포트와 함께 등록한다.
* MAC 주소 학습 기능.
* 목적지 MAC 주소에 대한 테이블이 등록되어 있지 않은 경우에는 모든 Port로 데이터를 허브같이 다 보내게 되고, 이를 *Flooding*이라고 한다.
* 출발지와 목적지의 MAC 주소가 테이블에 모두 등록되어 있을 경우 불필요한 데이터를 네트워크에 전송하지 않게되고 이를 *MAC 주소 필터링* 이라고한다.

## 데이터가 케이블에서 충돌하지 않는 구조

### 전이중 통신과 반이중 통신
* 랜으로 직접 송신부 수신부를 각각 연결한다면 전이중 통신방식이 된다.
* 허브같은 경우 더미 허브로 연결되게 되면 데이터들이 충돌되는 반이중 통신방식이기에 스위치(전이중 통신방식)을 이용하는 것이 효율적이며 표준이 되었다.

### 충돌 도메인이란?
* 허브같이 반이중 통신으로 인해 충돌이 일어날 수 있는 범위를 collision domain(충돌 도메인)이라고 한다.
* 허브를 사용하게 되면 허브 전체가 충돌도메인이 되지만, 스위치를 사용하게되면 그 범위는 MAC 주소 테이블이 연결된 그 한 네트워크만 해당되게된다.

### ARP(Address Resolution Protocol)
* 목적지 컴퓨터의 IP 주소를 이용하여 MAC 주소를 찾기 위한 프로토콜.
* 이더넷 프레임을 전송하려면 목적지 컴퓨터의 MAC 주소를 지정해야함.
* 출발지 컴퓨터가 목적지 주소를모르면 MAC 주소를 알아내기 위해 네트워크에 브로드캐스트를 하는데 이것을 ARP Request라고 한다.
* 지정된 IP를 갖고 있는 컴퓨터는 MAC 주소를 응답으로 보낸다. 이것을 ARP Reply 라고 한다.
* 출발지 컴퓨터는 MAC 주소를 얻고 이더넷 프레임을 만들 수 있다.
* 출발지 컴퓨터에서는 MAC 주소를 얻은 후에 MAC 주소와 IP 주소의 매핑 정보를 메모리에 보관한다. 이 것을 ARP Table이라고 한다.
* 이후 데이터 통신은 자신의 컴퓨터에 보관된 ARP 테이블을 참고하여 전송된다.

## 이더넷의 종류와 특징

### 이더넷 규격
* 다양한 이더넷 규격이 존재한다.
* 10BASE-T --> 10(통신속도 Mbps), BASE(BASEBAND라는 전송 방식), T(케이블 종류)

# 5. (OSI 3계층) 네트워크 계층: 목적지에 데이터 전달하기

## 네트워크 계층의 역할

### 네트워크 간의 연결 구조
* 데이터 링크 계층을 통해서라면 물리적으로 연결되어 있는 같은 네트워크에 있는 컴퓨터로는 데이터를 전송할 수 있지만, 인터넷이나 다른 네트워크로는 데이터를 전송할 수 없음
* 수 많은 네트워크가 연결된 환경에서 데이터 링크 계층의 기능만으로는 다른 네트워크로 데이터를 전송하기 힘들다.
* 서로 다른 네트워크끼리의 연결을 가능하게 하는 것이 "라우터"이다.
  * 라우터는 데이터의 목적지가 정해지면 해당 목적지까지 어떤 경로로 가는 것이 좋은지 알려주는 기능
* 네트워크에서도 데이터를 보내려면 목적지 주소가 반드시 있어야함
  * 랜에서는 MAC 주소만으로 해당 목적지를 알 수 있지만, 네트워크들을 식별하기 위해서는 IP주소를 식별해야함
* IP 주소는 어떤 네트워크의 어떤 컴퓨터인지를 구분할 수 있도록 하는 것이다.(다른 네트워크에 있는 목적지 설정가능)
* *라우팅* : 데이터를 어떤 경로로 보낼지 결정하는 것
* 거리에 관계없이 다른 네트워크로 데이터를 보낼 수 있음 --> 라우팅 테이블

### IP란?
* 네트워크 계층에서는 IP(Internet Protocol)이라는 프로토콜이 있음
* 데이터를 다른 네트워크에 있는 목적지까지 보내려면 라우터가 필요한데, 이는 IP가 있어서 가능한 것
* 네트워크 계층에서는 캡슐화를 진행할 때 IP 헤더를 붙임

![스크린샷 2021-09-22 오후 7 35 19](https://user-images.githubusercontent.com/67637935/134328770-ad570a89-0dd3-43d7-8390-8ab8f30dc338.png)

* IP 헤더에는 출발지 IP 주소와 목적지 IP 주소가 포함되어 있다는 것이 핵심!
* IP 프로토콜을 이용하여 캡슐화를 할때는 데이터에 IP 헤더가 추가되는데, 이렇게 만들어진 것을 IP패킷이라고 함

## IP 주소의 구조

### IP 주소란?
* 우편물을 보낼때 적는 주소 같은 느낌
* IP 주소는 ISP(인터넷 서비스 제공자)에게 받을 수 있음
* IPv4는 32bit로 43억개의 IP를 만들 수 있었으나, 부족해서 IPv6가 만들었음
* IP 주소에는 "공인IP"와 "사설IP"가 있음
  * "공인 IP"는 ISP로부터 제공 받을 수 있음
  * "사설 IP"는 인터넷에 직접연결된 라우터 이외에 라우터 다른 컴퓨터로 해당 IP를 뿌려주는 역할
  * 라우터에만 공인 IP를 할당하고, 랜 안에 있는 컴퓨터에는 랜의 네트워크 관리자가 자유롭게 사설 IP주소를 자동으로 할당해줌
* "공인IP"와 "사설IP"모두 32bit를 사용하고 있음(IPv4)
* 8bit(옥텟)씩 나누어, 각각을 십진수로 표현하고 있음 (실제로는 2진수)
* IP주소는 "네트워크 ID"와 "호스트 ID"로 나누어져있음
  * 네트워크 ID는 어떤 네트워크인지를 나타내고
  * 호스트 ID는 헤당 네트워크의 어느 컴퓨터인지 나타낸다.

## IP 주소의 클래스 구조

### IP 주소 클래스란?
* A,B,C 클래스가 있고, 각각은 Host ID, Network ID의 길이가 다름으로 구분된다.
  * A class = 32bit 중 상위 8bit:네트워크ID, 하위 24bit:호스트ID 
    * 1.0.0.0 ~ 127.255.255.255
    * 네트워크 ID: 0000 0001 ~ 0111 1111 (1~127)
    * 호스트 ID: 000000000000000000000000000~1111111111111111111111111
  * B class = 32bit 중 상위 16bit/16bit : 네트워크ID/호스트ID
    * 128.0.0.0 ~ 191.255.255.255
  * C class = 32bit 중 상위 24bit/8bit: 네트워크ID/호스트ID
    * 192.0.0.0 ~ 223.255.255.255

![스크린샷 2021-09-22 오후 8 15 15](https://user-images.githubusercontent.com/67637935/134333927-bfd7f2b8-fba6-463d-8232-d80a61c8fe74.png)


* 가정에서 사용하는 "사설IP"는 대체로 C클래스인 192.168.0.0~ 을 사용한다.

## 네트워크 주소와 브로드캐스트 주소의 구조

### 네트워크 주소와 브로드캐스트 주소란?
* 두 주소는 특별한 주소로 컴퓨터나 라우터가 자신은 IP로 사용하면 안되는 주소
* 네트워크 주소: HostID가 0인 주소
  * e.g) 192.168.x.0
  * 전체 네트워크에서 작은 네트워크를 식별하는데 사용되는 주소, 즉 대표되는 주소
* 브로드캐스트주소: HostID가 255인 주소
  * e.g) 192.168.x.255
  * 네으투어크에 있는 컴퓨터나 장비 모두에게 한 번에 데이터를 전송하는데 사용되는 전용 IP 주소

## 서브넷의 구조

### 서브넷이란?
* 대규모 네트워크를 작은 네트워크로 분할하여 브로드캐스트로 전송되는 패킷의 범위를 좁힐 수 있음

![스크린샷 2021-09-22 오후 8 20 29](https://user-images.githubusercontent.com/67637935/134334670-268fe145-b065-418e-b9e9-46c91c0162c8.png)

* 분할하는 것은 서브넷팅(subneting)이라고 하고, 분할된 네트워크를 서브넷(subnet)이라한다.
* 분할하게되면 기존의 A class로 NetworkID, HostID로 나눠져있던 IP주소가 NetworkID, SubnetID, HostID로 나눠지게된다.
* Aclass기준 HostID의 상위 10bit를 서브넷ID로 사용하게된다.

### 서브넷 마스트란?
* 서브넷 마스크 사용이유: IP 주소를 서브넷팅하면 어디까지가 네트워크 ID고 어디부터가 호스트 ID인지 판단하기 어려울때가 있음
* 네트워크ID와 호스트ID를 식별하기 위한 값이다.
* 32bit 값으로 Aclass는 255.0.0.0 (prefix: /8) / Bclass는 255.255.0.0 (prefix: /16) / Cclass는 255.255.255.0 (prefix: /24)이다.
* Q) 255.255.255.240 일때 class와 prefix표기법은?
  * A) C class, /28

## 라우터의 구조

### 라우터란?
* 서로 다른 네트워크와 통신하려면 라우터가 필요하다
* 라우터를 통해 네트워크를 분리할 수 있음 스위치로는 같은 대역대의 네트워크가 될 것임
* 라우터의 IP주소를 설정해야함
* 네트워크의 출입구를 설정하는 것으로 기본 게이트웨이(default gateway)라고 한다. : 네트워크의 출입구 개념으로 지정시킨다.(라우터의 포트 하나를)
* 추가적으로 Routing 작업을 해주어야 다른 네트워크 대역으로 보낼 수 있음(192.168.1.x --> 192.168.2.x)

### 라우팅이란?
* 라우팅이란 경로 정보를 기반으로 현재의 네트워크에서 다른 네트워크로 최적의 경로를 통해 데이터를 전송
* 이런 경로 정보를 등록되어 있는 테이블이 "라우팅 테이블"이다.
* 라우터간에 라우팅 정보를 교환하기 위한 프로토콜을 라우팅 프로토콜이라고 한다. (RIP, OSPF,BGP)가 있다.

# 6. (OSI 4계층) 전송 계층: 신뢰할 수 있는 데이터 전송하기

## 전송 계층의 역할

### 전송 계층의 두가지 역할
* 목적지에 신뢰할 수 있는 데이터를 전달 하기
  * 1. 전송 오류를 점검하는 기능
  * 2. 전송된 데이터의 목적지가 어떤 애플리케이션인지 식별하는 기능

### 연결형 통신과 비연결형 통신
* 신뢰성/정확성 vs 효율성
  * 연결형 통신: 신뢰성/정확성 --> TCP
    * 3-way Handshake 
  * 비연결형 통신: 효율성 --> UDP
    * 동영상 같이 신뢰 보단 일단 빠르게 보내야하는 것들이 UDP


## TCP의 구조

### TCP란?
* 신뢰성과 정확성을 우선으로 하는 연결형 통신 프로토콜
* TCP로 전송할 때 붙이는 헤더를 TCP 헤어달고 하고, 이 TCP 헤더가 붙은 데이터를 "세그먼트"라고 한다.
* IP헤더와 마찬가지로 TCP 헤더에 많은 의미가 담겨져있다.

![image](https://user-images.githubusercontent.com/67637935/134616783-0f3cfe81-3ceb-4ea2-bfeb-1f3bb675b993.png)

* 데이터를 전송하기 위해 "연결(connection)"이라는 가상의 독점 통신로를 확보해야한다.
* 독점 통신로를 확보하기 위해서 "코드 비트"를 확인해야한다.
* 코드 비트를 통해 "SYN" "ACK" "FIN"등 다양한 통신을 진행한다.
  * 3-way handshake (connect to disconnect)
    * 1. client 2 server : 000010 (SYN 1로 활성화)
    * 2. server 2 client : 010010 (ACK SYN 1로 활성화)
    * 3. client 2 server : 010000 (ACK 1로 활성화)
    
![image](https://user-images.githubusercontent.com/67637935/134618030-9689ac49-d230-4f84-b474-c4db80a298b8.png)

## 일련본호와 확인 응답 번호의 구조

### 일련번호와 확인 응답 번호란?
* TCP는 데이터를 분할해서 보내는데 "일련번호"는 송신 측에서 수신측에 "이 데이터가 몇번째 데이터 인지" 알려주는 역할을 한다.
* 원래의 데이터의 몇 번째 데이터를 받았는지 일련번호의 "순서", "연속된 번호"라는 뜻이 있다.
* 확인 응답 번호란, 몇번째 데이터를 수신했는지 송신측에 알려주는 역할을 한다.
* 데이터가 전송완료 될 때 까지 반복한다.

### 윈도우 크기란?
* 반복적으로 해당 데이터 통신을 처음부터 다시 하면 효율성이 너무 떨어진다.
* 받은 세그먼크를 일시적으로 보관하는 장소(buffer)가 따로있다.
* 세그먼트를 연속해서 보내고 이후 수신측이 대응하게 된다.
* 수신 측은 대량으로 데이터가 전송되면 보관하지 못하고 넘치는 "오버플로"가 발생하게 된다.
* 오버플로우가 발생하지 않도록 버퍼의 한계 크기를 알고 있어야한다.
* TCP 헤더의 "윈도우 크기" 값에 해당한다.
* 이 윈도우 크기는 초기에 연결할 때 3-way handshake 과정 중에서 확인한다.

## 포트 번호의 구조
 
### 포트 번호란?
* 어떤 어플리케이션의 통신인지를 확인하는 것
* TCP 헤더의 출발지 포트 번호와 목적지 포트 번호가 필요하다.
* TCP 헤더에 포트 번호가 있기 때문에 어플리케이션을 구분할 수 있다.
* well-known ports: 잘 알려진 포트 (0~1023)
* 1024는 예약 포트로 사용하지 않는다
* 1025부터는 랜덤포트로 수신측의 송신 포트로 사용한다.
  * 어플리케이션 & 포트번호
  * SSH/22, SMTP/25, DNS/53, HTTP/80, POP3/110, HTTPS/443
* 포트 번호를 붙이지 않고 통신하게 되면 데이터가 도착하게 되더라도 어플리케이션까지는 도착할 수 없게된다.
* 서버측에 접근하기 위한 포트는 정해놔야하지만 client 측으로 보내는 데이터는 포트가 정해져 있지 않아도된다. (자동할당 되기 떄문에)
* 즉, client의 출발지 포트 번호는 랜덤으로 설정이 된다.

##  UDP의 구조

### UDP란?
* 비연결형 통신으로써 TCP만큼 신뢰성을 보장하기 위한 과정이 없다. 대신에 효율성을 중요하게 여기는 프로토콜이다.


### UDP헤더란?
* UDP를 사용하면 같은 랜에 있는 컴퓨터나 네트워크 장비에 데이터를 일괄적으로 보낼 수 있다. (브로드캐스트)
* 올바른 목적지의 애플리케이션으로 데이터를 보내기 위해 필요한 정보가 모여있다.
* UDP에서 전송계층 연결 과정 중 헤더가 붙어서 통신하게 되고, 이를 UDP 세그멘테이션 전송방법이라 한다.

![image](https://user-images.githubusercontent.com/67637935/134619969-b71b25e1-3479-4d29-ba16-d954574d7846.png)

# 7. (OSI 5,6포함, 7계층) 응용 계층: 애플리케이션에 데이터 전송하기

## 응용 계층의 역할

### 응용 계층의 역할
* 서비스를 요청하는 측(사용자 측)에서 사용하는 애플리케이션으로 분류할 수 있음
* 서비스 요청: client
* 서비스 제공: server
* 세션 계층과 표현계층을 한번에 묶어서 응용 계층이라 칭할 수 있다.
* 클라이언트 측의 어플리케이션이 서버 측 어플리케이션과 통신하려면 응용 계층의 프로토콜을 사용해야만한다.
  * HTTP: 웹접속
  * DNS: 이름 해석
  * FTP: file 전송
  * SMTP: 이메일 전송
  * POP: 이메일 수신

![image](https://user-images.githubusercontent.com/67637935/134840631-656e7919-cd88-4b56-b6ce-26e03e123cf2.png)

## 웹 서버의 구조 (웹 사이트 접속)

### WWW 란?
* WWW는  HTML, URL, HTTP 세가지 기술이 사용된다.
* 이동한 사이트에서는 html 파일이나 이미지 파일이 웹 서버에서 전송된다.
  * client --> server : index.html을 보내달라
  * server --> client : index.html을 보내준다.
  * client --> server : picture.jpg를 보내달라
  * server --> client : picture.jpy를 보내준다.
  * 이렇기에 글이랑 사진이랑 전송 받는 속도가 달라진다.

### HTTP란?
* 웹 사이트를 보기 위해서 서버(웹 서버의 프로그램)의 80번 포트를 사용하여 HTTP통신을 진행한다.
* client --> server : Get/index.html/HTTP/1.1
* server --> client : HTTP/1.1 200 OK
* 클라이언트가 데이터를 요청할 때 GET이라고 하고 요청 정보, 파일 이름, 버전 등을 서버에 전송한다.
* 서버는 응답으로 요청을 정상적으로 처리했다는 "OK" 정보를 반환하고  index.html을 클라이언트에게 보낸다.
* HTTP 1.0에서는 계속 반복적으로 하나 요청하고 끊고 하나 요청하고 끊고 해서 효용성이 적었음
* HTTP 1.1에서 한번 연결하고 다 전달할때까지 끊지 않도록 했음 대신 요청은 무조건 순서대로 처리해야했음
* HTTP 2.0에서는 순서대로 처리하지 않고 빨리 온 것 부터 처리하도록 수정됨

## DNS 서버의 구조 (이름 해석)

### 도메인 이름이란?
* 컴퓨터에 IP 주소가 있어서 인터넷을 통해 웹 서버에 접속할 수 있었다.
* 하지만 다 기억하기 힘듦으로 IP대신 이름을 입력할 수 있게 하는 것
* Client --> DNS : 이름 줄테니까 ip 내놔
* DNS --> Client : 음 이 이름은!! 여기 IP
* Client --> Server: IP로 접속
* DNS는 여러개의 서버에 나눠 저장되어 있음 .기준일듯?

## 메일 서버의 구조 (SMTP, PoP3)

### 메일의 송수신 구조
* 메일을 보내는데 사용되는 프로토콜은 SMTP이고 받는데 사용되는 프로토콜은 POP3이다.
* SMTP 는 25번 포트,  POP3는 110번 포트 사용
* clinet가 Server로 SMTP 25번 포트를 사용하여 이메일 전송
* Server to Server로 25번 포트로 메일을 전송함
* Server에서는 Client로 POP3 110번 포트 사용하여 받는 client한테 메일을 전송해줌
* Server는 각각 마다 메일 박스 가 있어서 POP3는 쌓여진 MailBox에서 메일이 있는지 찾고, 받는 컴퓨터에게 메일을 보내주는 느낌

## PING
* ICMP 라는 프로토콜을 사용하여 목적지 컴퓨터에 패킷을 보냈을때 정상적으로 답이 오는지를 확인하는 것

# 8.네트워크 전체 흐름 살펴보기

## 랜 카드에서의 데이터 전달과 처리

### 네트워크의 구성
1. 응용 계층: 어플케이션 등에서 사용하는 데이터를 송수신하는 데 필요하다
2. 전송 계층: 목적지에 데이터를 정확하게 전달하는 데 필요하다.
3. 네트워크 계층: 다른 네트워크에 있는 목적지에 데이터를 전달하는데 필요하다.
4. 데이터 링크 계층: 랜에서 데이터를 송수신하는 데 필요하다.
5. 물리 계층: 데이터를 전기 신호로 변환하는 데 필요하다.

![ㅁ](https://images.velog.io/images/gndan4/post/067c5d14-a66f-46c1-9491-9cf6122b7539/IMG_0433.jpg)
![ㅁ](https://images.velog.io/images/gndan4/post/a5f3a7fb-b98d-49d6-acfe-76c29c5f911b/IMG_0434.jpg)

### 컴퓨터의 데이터가 전기 신호로 변환되는 과정
* 캡슐화
![ㅁ](https://images.velog.io/images/gndan4/post/9dd55fe0-3be7-4dd6-a218-8368468d27d3/IMG_0435.jpg)


* 시나리오 client 기준: client가 url로 접속함
  1.  client의 PC에서 url을 누른다.
  2.  응용 계층에서 HTTP(S) 프로토콜을 통해 GET/index.html HTTP/1.1 ~ 같은 HTTP 메세지를 구성한다.
  3.  데이터(메세지)가 전송 계층에 전달되고 전송 계층에서 TCP헤더가 붙게된다.
  4.  전송층의 TCP헤더에 출발지포트번호(잘알려진 번호가 아닌 1025이상인 포트 중에서 무작위로 선택됨)와 목적지포트번호(어플리케이션 프로토콜 별 포트번호 작성)가 작성되어있음
  5.  TCP헤더가 붙게되면 메세지 --> "세그먼트"가 됨
  6.  세그먼트가 된 데이터는 네트워크 계층에 도착함
  7.  네트워크 계층에서는 IP헤더(출발지 컴퓨터의 IP와 목적지 서버의 IP가 추가됨) 
  8.  세그먼트에 IP 헤더가 붙게되면 "IP 패킷"이됨
  9.  IP 패킷은 데이터링크계층으로 보내짐
  10.  데이터 링크 계층에서는 이더넷 헤더와 트레일러가 붙게되고 "이더넷 프레임"이 됨
  11.  이더넷 프레임이 된 데이터는 "랜카드"를 통해 물리계층에서 전기신호로 변환된다.

## 스위치와 라우터에서의 데이터 전달과 처리

### 스위치 A에서의 데이터 전달과 처리
* 물리계층 --> 데이터 링크 계층 --> 물리 계층으로 전달(스위치A)
![a](https://images.velog.io/images/gndan4/post/a86bbd34-8862-4912-9637-3382ef2d6928/IMG_0436.jpg)

### 라우터에서의 데이터 전달과 처리
![A](https://images.velog.io/images/gndan4/post/eb62ccd5-c493-40ea-a679-1e680e7cbb19/IMG_0437.jpg)
* 물리계층 --> 데이터 링크 계층 --> 네트워크 계층으로 전달
* 스위치 A에서 라우터 A로 도착하게 되면 라우터 A는 데이터 링크 계층에서 이더넷 프레임의 목적지 MAC주소와 자신의 MAC주소를 비교하고 같은 경우에 이더넷 헤더와 트레일러를 분리하는 역캡슐화를 진행
* 이후 네트워크 계층에 전달되고 자신의 _라우팅 테이블과 목적지 IP주소_를 비교한다.
* 라우터 A의 라우팅 테이블에서 목적지 IP 주소의 경로를 알 수 있음으로 라우팅할 수 있다.
* 현재 출발지 IP를 192.168.1.1에서 172.16.0.1로 바꾼다.
![A](https://images.velog.io/images/gndan4/post/f37f4853-abbf-4912-8bff-9a17c5ace6a6/IMG_0438.jpg)

* 그 이후 다시 라우터 A에서 라우터 B로 보내지도록 목적지 MAC 주소를 라우터B로 바꾼다. 
* 이후 라우터 A에서 이더넷과 트레일러를 붙여서 이더넷 프레임으로 바꾸고 이후 전기적인 신호로 변환하여 라우터 B로 도착하게된다.
* 라우터 B로 도착한 전기적 신호는 물리계층을 통과하고 데이터 링크 계층에서 목적지 MAC주소가 자신과 일치하는지 확인한다.

![a](https://images.velog.io/images/gndan4/post/a1678dd9-6784-4eff-befa-db2a4debbc04/IMG_0439.jpg)

* 라우팅 테이블과 비교하여 해당 목적지 IP가 라우팅 테이블에 있는지 확인한다.
* 있을 경우 현재 출발지 IP 주소를 172.16.0.1에서 192.168.10.1로 변경한다.

![ㅁ](https://images.velog.io/images/gndan4/post/57c0ebcb-b7ec-4db4-8b4e-6ac6c02b6513/IMG_0442.jpg)
* 네트워크 계층에서 변경된 패킷을 토대로 데이터 링크 계층에서 목적지 MAC 주소와 출발지 MAC주소를 웹서버의 MAC주소 및 라우터 B의 MAC주소로 변경한다.
* 변경된 이더넷 헤더와, 트레일러를 붙여서 이더넷 프레임으로 만든 뒤 물리계층에서 전기신호로 변경하여 스위치 B로 전달한다.

### 스위치 B에서의 데이터 전달과 처리

* 스위치 B에서는 데이터 링크 계층으로 가서 이더넷 헤더의 목적지 MAC 주소를 확인하고 웹서버에 데이터를 전달한다.

![ㅁ](https://images.velog.io/images/gndan4/post/0963699f-4b8f-452e-833f-2203c929e764/IMG_0444.jpg)

## 웹 서버에서의 데이터 전달과 처리

* 역캡슐화!!
![ㅁ](https://images.velog.io/images/gndan4/post/777a5938-e4e8-48d7-a5ee-a4c949e4a2e9/IMG_0446.jpg)

* 요청 한번에 관한 것인데도 엄청나게 많은 캡슐화와 역캡슐화가 이뤄진다.

## Client 2 Server 
![image](https://user-images.githubusercontent.com/67637935/137458209-cd87cacf-2c3b-488e-8929-cdf5dbb67bb9.png)
